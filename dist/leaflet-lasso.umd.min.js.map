{"version":3,"file":"leaflet-lasso.umd.min.js","sources":["../node_modules/tslib/tslib.es6.js","../src/lasso-polygon.ts","../node_modules/@terraformer/spatial/dist/t-spatial.esm.js","../src/calc.ts","../node_modules/style-inject/dist/style-inject.es.js","../src/lasso-handler.ts","../src/lasso-control.ts","../src/index.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import * as L from 'leaflet';\r\nimport * as GeoJSON from 'geojson';\r\n\r\nexport class LassoPolygon extends L.Layer {\r\n    readonly polyline: L.Polyline;\r\n    readonly polygon: L.Polygon;\r\n\r\n    constructor(latlngs: L.LatLngExpression[], options?: L.PolylineOptions) {\r\n        super();\r\n\r\n        this.polyline = L.polyline(latlngs, options);\r\n        this.polygon = L.polygon(latlngs, { ...options, weight: 0 });\r\n    }\r\n\r\n    onAdd(map: L.Map): this {\r\n        this.polyline.addTo(map);\r\n        this.polygon.addTo(map);\r\n\r\n        return this;\r\n    }\r\n\r\n    onRemove(): this {\r\n        this.polyline.remove();\r\n        this.polygon.remove();\r\n\r\n        return this;\r\n    }\r\n\r\n    addLatLng(latlng: L.LatLngExpression): this {\r\n        this.polyline.addLatLng(latlng);\r\n        this.polygon.addLatLng(latlng);\r\n\r\n        return this;\r\n    }\r\n\r\n    getLatLngs(): L.LatLng[] {\r\n        return this.polygon.getLatLngs()[0] as L.LatLng[];\r\n    }\r\n\r\n    toGeoJSON(): GeoJSON.Feature<GeoJSON.Polygon> {\r\n        return this.polygon.toGeoJSON() as GeoJSON.Feature<GeoJSON.Polygon>;\r\n    }\r\n}","/* @preserve\n* @terraformer/spatial - v2.0.6 - MIT\n* Copyright (c) 2012-2020 Environmental Systems Research Institute, Inc.\n* Mon May 18 2020 14:30:36 GMT-0700 (Pacific Daylight Time)\n*/\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\n/* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\nvar isNumber = function isNumber(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n};\n\nvar edgeIntersectsEdge = function edgeIntersectsEdge(a1, a2, b1, b2) {\n  var uaT = (b2[0] - b1[0]) * (a1[1] - b1[1]) - (b2[1] - b1[1]) * (a1[0] - b1[0]);\n  var ubT = (a2[0] - a1[0]) * (a1[1] - b1[1]) - (a2[1] - a1[1]) * (a1[0] - b1[0]);\n  var uB = (b2[1] - b1[1]) * (a2[0] - a1[0]) - (b2[0] - b1[0]) * (a2[1] - a1[1]);\n\n  if (uB !== 0) {\n    var ua = uaT / uB;\n    var ub = ubT / uB;\n\n    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nvar arraysIntersectArrays = function arraysIntersectArrays(a, b) {\n  if (isNumber(a[0][0])) {\n    if (isNumber(b[0][0])) {\n      for (var i = 0; i < a.length - 1; i++) {\n        for (var j = 0; j < b.length - 1; j++) {\n          if (edgeIntersectsEdge(a[i], a[i + 1], b[j], b[j + 1])) {\n            return true;\n          }\n        }\n      }\n    } else {\n      for (var k = 0; k < b.length; k++) {\n        if (arraysIntersectArrays(a, b[k])) {\n          return true;\n        }\n      }\n    }\n  } else {\n    for (var l = 0; l < a.length; l++) {\n      if (arraysIntersectArrays(a[l], b)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\nvar coordinatesContainPoint = function coordinatesContainPoint(coordinates, point) {\n  var contains = false;\n\n  for (var i = -1, l = coordinates.length, j = l - 1; ++i < l; j = i) {\n    if ((coordinates[i][1] <= point[1] && point[1] < coordinates[j][1] || coordinates[j][1] <= point[1] && point[1] < coordinates[i][1]) && point[0] < (coordinates[j][0] - coordinates[i][0]) * (point[1] - coordinates[i][1]) / (coordinates[j][1] - coordinates[i][1]) + coordinates[i][0]) {\n      contains = !contains;\n    }\n  }\n\n  return contains;\n};\nvar pointsEqual = function pointsEqual(a, b) {\n  for (var i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nvar EARTH_RADIUS = 6378137;\nvar DEGREES_PER_RADIAN = 57.295779513082320;\nvar RADIANS_PER_DEGREE = 0.017453292519943;\nvar MercatorCRS = {\n  type: 'link',\n  properties: {\n    href: 'http://spatialreference.org/ref/sr-org/6928/ogcwkt/',\n    type: 'ogcwkt'\n  }\n};\nvar GeographicCRS = {\n  type: 'link',\n  properties: {\n    href: 'http://spatialreference.org/ref/epsg/4326/ogcwkt/',\n    type: 'ogcwkt'\n  }\n};\n\n/*\nInternal: Convert radians to degrees. Used by spatial reference converters.\n*/\n\nvar radToDeg = function radToDeg(rad) {\n  return rad * DEGREES_PER_RADIAN;\n};\n/*\nInternal: Convert degrees to radians. Used by spatial reference converters.\n*/\n\nvar degToRad = function degToRad(deg) {\n  return deg * RADIANS_PER_DEGREE;\n};\nvar positionToGeographic = function positionToGeographic(position) {\n  var x = position[0];\n  var y = position[1];\n  return [radToDeg(x / EARTH_RADIUS) - Math.floor((radToDeg(x / EARTH_RADIUS) + 180) / 360) * 360, radToDeg(Math.PI / 2 - 2 * Math.atan(Math.exp(-1.0 * y / EARTH_RADIUS)))];\n};\nvar positionToMercator = function positionToMercator(position) {\n  var lng = position[0];\n  var lat = Math.max(Math.min(position[1], 89.99999), -89.99999);\n  return [degToRad(lng) * EARTH_RADIUS, EARTH_RADIUS / 2.0 * Math.log((1.0 + Math.sin(degToRad(lat))) / (1.0 - Math.sin(degToRad(lat))))];\n};\n\n/*\nInternal: used for sorting\n*/\n\nvar compSort = function compSort(p1, p2) {\n  if (p1[0] > p2[0]) {\n    return -1;\n  } else if (p1[0] < p2[0]) {\n    return 1;\n  } else if (p1[1] > p2[1]) {\n    return -1;\n  } else if (p1[1] < p2[1]) {\n    return 1;\n  } else {\n    return 0;\n  }\n};\n/*\n  Internal: -1,0,1 comparison function\n  */\n\nvar cmp = function cmp(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else {\n    return 0;\n  }\n};\n/*\n  Internal: used to determine turn\n  */\n\n\nvar turn = function turn(p, q, r) {\n  // Returns -1, 0, 1 if p,q,r forms a right, straight, or left turn.\n  return cmp((q[0] - p[0]) * (r[1] - p[1]) - (r[0] - p[0]) * (q[1] - p[1]), 0);\n};\n/*\n  Internal: used to determine euclidean distance between two points\n  */\n\n\nvar euclideanDistance = function euclideanDistance(p, q) {\n  // Returns the squared Euclidean distance between p and q.\n  var dx = q[0] - p[0];\n  var dy = q[1] - p[1];\n  return dx * dx + dy * dy;\n};\n\nvar nextHullPoint = function nextHullPoint(points, p) {\n  // Returns the next point on the convex hull in CCW from p.\n  var q = p;\n\n  for (var r in points) {\n    var t = turn(p, q, points[r]);\n\n    if (t === -1 || t === 0 && euclideanDistance(p, points[r]) > euclideanDistance(p, q)) {\n      q = points[r];\n    }\n  }\n\n  return q;\n};\n\nvar coordinateConvexHull = function coordinateConvexHull(points) {\n  // implementation of the Jarvis March algorithm\n  // adapted from http://tixxit.wordpress.com/2009/12/09/jarvis-march/\n  if (points.length === 0) {\n    return [];\n  } else if (points.length === 1) {\n    return points;\n  } // Returns the points on the convex hull of points in CCW order.\n\n\n  var hull = [points.sort(compSort)[0]];\n\n  for (var p = 0; p < hull.length; p++) {\n    var q = nextHullPoint(points, hull[p]);\n\n    if (q !== hull[0]) {\n      hull.push(q);\n    }\n  }\n\n  return hull;\n};\n/*\nInternal: Returns a copy of coordinates for a closed polygon\n*/\n\nvar closedPolygon = function closedPolygon(coordinates) {\n  var outer = [];\n\n  for (var i = 0; i < coordinates.length; i++) {\n    var inner = coordinates[i].slice();\n\n    if (pointsEqual(inner[0], inner[inner.length - 1]) === false) {\n      inner.push(inner[0]);\n    }\n\n    outer.push(inner);\n  }\n\n  return outer;\n};\n/*\nInternal: safe warning\n*/\n\nfunction warn() {\n  var args = Array.prototype.slice.apply(arguments);\n\n  if (typeof console !== 'undefined' && console.warn) {\n    console.warn.apply(console, args);\n  }\n}\n/*\nInternal: Loop over each array in a geojson object and apply a function to it. Used by spatial reference converters.\n*/\n\nvar eachPosition = function eachPosition(coordinates, func) {\n  for (var i = 0; i < coordinates.length; i++) {\n    // we found a number so lets convert the pair\n    if (typeof coordinates[i][0] === 'number') {\n      coordinates[i] = func(coordinates[i]);\n    } // we found an coordinates array it again and run the function against it\n\n\n    if (_typeof(coordinates[i]) === 'object') {\n      coordinates[i] = eachPosition(coordinates[i], func);\n    }\n  }\n\n  return coordinates;\n};\n/*\nApply a function agaist all positions in a geojson object. Used by spatial reference converters.\n*/\n\n\nvar applyConverter = function applyConverter(geojson, converter, noCrs) {\n  if (geojson.type === 'Point') {\n    geojson.coordinates = converter(geojson.coordinates);\n  } else if (geojson.type === 'Feature') {\n    geojson.geometry = applyConverter(geojson.geometry, converter, true);\n  } else if (geojson.type === 'FeatureCollection') {\n    for (var f = 0; f < geojson.features.length; f++) {\n      geojson.features[f] = applyConverter(geojson.features[f], converter, true);\n    }\n  } else if (geojson.type === 'GeometryCollection') {\n    for (var g = 0; g < geojson.geometries.length; g++) {\n      geojson.geometries[g] = applyConverter(geojson.geometries[g], converter, true);\n    }\n  } else {\n    geojson.coordinates = eachPosition(geojson.coordinates, converter);\n  }\n\n  if (!noCrs) {\n    if (converter === positionToMercator) {\n      geojson.crs = MercatorCRS;\n    }\n  }\n\n  if (converter === positionToGeographic) {\n    delete geojson.crs;\n  }\n\n  return geojson;\n};\nvar coordinatesEqual = function coordinatesEqual(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  var na = a.slice().sort(compSort);\n  var nb = b.slice().sort(compSort);\n\n  for (var i = 0; i < na.length; i++) {\n    if (na[i].length !== nb[i].length) {\n      return false;\n    }\n\n    for (var j = 0; j < na.length; j++) {\n      if (na[i][j] !== nb[i][j]) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n};\n\n/*\nInternal: Calculate an bounding box from an nested array of positions\n[\n  [\n    [ [lng, lat],[lng, lat],[lng, lat] ]\n  ]\n  [\n    [lng, lat],[lng, lat],[lng, lat]\n  ]\n  [\n    [lng, lat],[lng, lat],[lng, lat]\n  ]\n]\n*/\nvar calculateBoundsFromNestedArrays = function calculateBoundsFromNestedArrays(array) {\n  var x1 = null;\n  var x2 = null;\n  var y1 = null;\n  var y2 = null;\n\n  for (var i = 0; i < array.length; i++) {\n    var inner = array[i];\n\n    for (var j = 0; j < inner.length; j++) {\n      var lonlat = inner[j];\n      var lon = lonlat[0];\n      var lat = lonlat[1];\n\n      if (x1 === null) {\n        x1 = lon;\n      } else if (lon < x1) {\n        x1 = lon;\n      }\n\n      if (x2 === null) {\n        x2 = lon;\n      } else if (lon > x2) {\n        x2 = lon;\n      }\n\n      if (y1 === null) {\n        y1 = lat;\n      } else if (lat < y1) {\n        y1 = lat;\n      }\n\n      if (y2 === null) {\n        y2 = lat;\n      } else if (lat > y2) {\n        y2 = lat;\n      }\n    }\n  }\n\n  return [x1, y1, x2, y2];\n};\n/*\nInternal: Calculate a bounding box from an array of arrays of arrays\n[\n  [ [lng, lat],[lng, lat],[lng, lat] ]\n  [ [lng, lat],[lng, lat],[lng, lat] ]\n  [ [lng, lat],[lng, lat],[lng, lat] ]\n]\n*/\n\n\nvar calculateBoundsFromNestedArrayOfArrays = function calculateBoundsFromNestedArrayOfArrays(array) {\n  var x1 = null;\n  var x2 = null;\n  var y1 = null;\n  var y2 = null;\n\n  for (var i = 0; i < array.length; i++) {\n    var inner = array[i]; // return calculateBoundsFromNestedArrays(inner); // more DRY?\n\n    for (var j = 0; j < inner.length; j++) {\n      var innerinner = inner[j];\n\n      for (var k = 0; k < innerinner.length; k++) {\n        var lonlat = innerinner[k];\n        var lon = lonlat[0];\n        var lat = lonlat[1];\n\n        if (x1 === null) {\n          x1 = lon;\n        } else if (lon < x1) {\n          x1 = lon;\n        }\n\n        if (x2 === null) {\n          x2 = lon;\n        } else if (lon > x2) {\n          x2 = lon;\n        }\n\n        if (y1 === null) {\n          y1 = lat;\n        } else if (lat < y1) {\n          y1 = lat;\n        }\n\n        if (y2 === null) {\n          y2 = lat;\n        } else if (lat > y2) {\n          y2 = lat;\n        }\n      }\n    }\n  }\n\n  return [x1, y1, x2, y2];\n};\n/*\nInternal: Calculate a bounding box from an array of positions\n[\n  [lng, lat],[lng, lat],[lng, lat]\n]\n*/\n\n\nvar calculateBoundsFromArray = function calculateBoundsFromArray(array) {\n  var x1 = null;\n  var x2 = null;\n  var y1 = null;\n  var y2 = null;\n\n  for (var i = 0; i < array.length; i++) {\n    var lonlat = array[i];\n    var lon = lonlat[0];\n    var lat = lonlat[1];\n\n    if (x1 === null) {\n      x1 = lon;\n    } else if (lon < x1) {\n      x1 = lon;\n    }\n\n    if (x2 === null) {\n      x2 = lon;\n    } else if (lon > x2) {\n      x2 = lon;\n    }\n\n    if (y1 === null) {\n      y1 = lat;\n    } else if (lat < y1) {\n      y1 = lat;\n    }\n\n    if (y2 === null) {\n      y2 = lat;\n    } else if (lat > y2) {\n      y2 = lat;\n    }\n  }\n\n  return [x1, y1, x2, y2];\n};\n/*\nInternal: Calculate an bounding box for a feature collection\n*/\n\n\nvar calculateBoundsForFeatureCollection = function calculateBoundsForFeatureCollection(featureCollection) {\n  var extents = [];\n\n  for (var i = featureCollection.features.length - 1; i >= 0; i--) {\n    var extent = calculateBounds(featureCollection.features[i].geometry);\n    extents.push([extent[0], extent[1]]);\n    extents.push([extent[2], extent[3]]);\n  }\n\n  return calculateBoundsFromArray(extents);\n};\n/*\nInternal: Calculate an bounding box for a geometry collection\n*/\n\n\nvar calculateBoundsForGeometryCollection = function calculateBoundsForGeometryCollection(geometryCollection) {\n  var extents = [];\n\n  for (var i = geometryCollection.geometries.length - 1; i >= 0; i--) {\n    var extent = calculateBounds(geometryCollection.geometries[i]);\n    extents.push([extent[0], extent[1]]);\n    extents.push([extent[2], extent[3]]);\n  }\n\n  return calculateBoundsFromArray(extents);\n};\n\nvar calculateBounds = function calculateBounds(geojson) {\n  if (geojson.type) {\n    switch (geojson.type) {\n      case 'Point':\n        return [geojson.coordinates[0], geojson.coordinates[1], geojson.coordinates[0], geojson.coordinates[1]];\n\n      case 'MultiPoint':\n        return calculateBoundsFromArray(geojson.coordinates);\n\n      case 'LineString':\n        return calculateBoundsFromArray(geojson.coordinates);\n\n      case 'MultiLineString':\n        return calculateBoundsFromNestedArrays(geojson.coordinates);\n\n      case 'Polygon':\n        return calculateBoundsFromNestedArrays(geojson.coordinates);\n\n      case 'MultiPolygon':\n        return calculateBoundsFromNestedArrayOfArrays(geojson.coordinates);\n\n      case 'Feature':\n        return geojson.geometry ? calculateBounds(geojson.geometry) : null;\n\n      case 'FeatureCollection':\n        return calculateBoundsForFeatureCollection(geojson);\n\n      case 'GeometryCollection':\n        return calculateBoundsForGeometryCollection(geojson);\n\n      default:\n        throw new Error('Unknown type: ' + geojson.type);\n    }\n  }\n\n  return null;\n};\n\nvar convexHull = function convexHull(geojson) {\n  var coordinates = [];\n  var i;\n  var j;\n\n  if (geojson.type === 'Point') {\n    return null;\n  } else if (geojson.type === 'LineString' || geojson.type === 'MultiPoint') {\n    if (geojson.coordinates && geojson.coordinates.length >= 3) {\n      coordinates = geojson.coordinates;\n    } else {\n      return null;\n    }\n  } else if (geojson.type === 'Polygon' || geojson.type === 'MultiLineString') {\n    if (geojson.coordinates && geojson.coordinates.length > 0) {\n      for (i = 0; i < geojson.coordinates.length; i++) {\n        coordinates = coordinates.concat(geojson.coordinates[i]);\n      }\n\n      if (coordinates.length < 3) {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  } else if (geojson.type === 'MultiPolygon') {\n    if (geojson.coordinates && geojson.coordinates.length > 0) {\n      for (i = 0; i < geojson.coordinates.length; i++) {\n        for (j = 0; j < geojson.coordinates[i].length; j++) {\n          coordinates = coordinates.concat(geojson.coordinates[i][j]);\n        }\n      }\n\n      if (coordinates.length < 3) {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  } else if (geojson.type === 'Feature') {\n    return convexHull(geojson.geometry);\n  }\n\n  return {\n    type: 'Polygon',\n    coordinates: closedPolygon([coordinateConvexHull(coordinates)])\n  };\n};\nvar isConvex = function isConvex(points) {\n  var ltz;\n\n  for (var i = 0; i < points.length - 3; i++) {\n    var p1 = points[i];\n    var p2 = points[i + 1];\n    var p3 = points[i + 2];\n    var v = [p2[0] - p1[0], p2[1] - p1[1]]; // p3.x * v.y - p3.y * v.x + v.x * p1.y - v.y * p1.x\n\n    var res = p3[0] * v[1] - p3[1] * v[0] + v[0] * p1[1] - v[1] * p1[0];\n\n    if (i === 0) {\n      if (res < 0) {\n        ltz = true;\n      } else {\n        ltz = false;\n      }\n    } else {\n      if (ltz && res > 0 || !ltz && res < 0) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n};\n\nvar polygonContainsPoint = function polygonContainsPoint(polygon, point) {\n  if (polygon && polygon.length) {\n    if (polygon.length === 1) {\n      // polygon with no holes\n      return coordinatesContainPoint(polygon[0], point);\n    } else {\n      // polygon with holes\n      if (coordinatesContainPoint(polygon[0], point)) {\n        for (var i = 1; i < polygon.length; i++) {\n          if (coordinatesContainPoint(polygon[i], point)) {\n            return false; // found in hole\n          }\n        }\n\n        return true;\n      } else {\n        return false;\n      }\n    }\n  } else {\n    return false;\n  }\n};\n\nvar within = function within(geoJSON, comparisonGeoJSON) {\n  var coordinates, i, contains; // if we are passed a feature, use the polygon inside instead\n\n  if (comparisonGeoJSON.type === 'Feature') {\n    comparisonGeoJSON = comparisonGeoJSON.geometry;\n  } // point.within(point) :: equality\n\n\n  if (comparisonGeoJSON.type === 'Point') {\n    if (geoJSON.type === 'Point') {\n      return pointsEqual(geoJSON.coordinates, comparisonGeoJSON.coordinates);\n    }\n  } // point.within(multilinestring)\n\n\n  if (comparisonGeoJSON.type === 'MultiLineString') {\n    if (geoJSON.type === 'Point') {\n      for (i = 0; i < geoJSON.coordinates.length; i++) {\n        var linestring = {\n          type: 'LineString',\n          coordinates: comparisonGeoJSON.coordinates[i]\n        };\n\n        if (within(geoJSON, linestring)) {\n          return true;\n        }\n      }\n    }\n  } // point.within(linestring), point.within(multipoint)\n\n\n  if (comparisonGeoJSON.type === 'LineString' || comparisonGeoJSON.type === 'MultiPoint') {\n    if (geoJSON.type === 'Point') {\n      for (i = 0; i < comparisonGeoJSON.coordinates.length; i++) {\n        if (geoJSON.coordinates.length !== comparisonGeoJSON.coordinates[i].length) {\n          return false;\n        }\n\n        if (pointsEqual(geoJSON.coordinates, comparisonGeoJSON.coordinates[i])) {\n          return true;\n        }\n      }\n    }\n  }\n\n  if (comparisonGeoJSON.type === 'Polygon') {\n    // polygon.within(polygon)\n    if (geoJSON.type === 'Polygon') {\n      // check for equal polygons\n      if (comparisonGeoJSON.coordinates.length === geoJSON.coordinates.length) {\n        for (i = 0; i < geoJSON.coordinates.length; i++) {\n          if (coordinatesEqual(geoJSON.coordinates[i], comparisonGeoJSON.coordinates[i])) {\n            return true;\n          }\n        }\n      }\n\n      if (geoJSON.coordinates.length && polygonContainsPoint(comparisonGeoJSON.coordinates, geoJSON.coordinates[0][0])) {\n        return !arraysIntersectArrays(closedPolygon(geoJSON.coordinates), closedPolygon(comparisonGeoJSON.coordinates));\n      } else {\n        return false;\n      } // point.within(polygon)\n\n    } else if (geoJSON.type === 'Point') {\n      return polygonContainsPoint(comparisonGeoJSON.coordinates, geoJSON.coordinates); // linestring/multipoint withing polygon\n    } else if (geoJSON.type === 'LineString' || geoJSON.type === 'MultiPoint') {\n      if (!geoJSON.coordinates || geoJSON.coordinates.length === 0) {\n        return false;\n      }\n\n      for (i = 0; i < geoJSON.coordinates.length; i++) {\n        if (polygonContainsPoint(comparisonGeoJSON.coordinates, geoJSON.coordinates[i]) === false) {\n          return false;\n        }\n      }\n\n      return true; // multilinestring.within(polygon)\n    } else if (geoJSON.type === 'MultiLineString') {\n      for (i = 0; i < geoJSON.coordinates.length; i++) {\n        var ls = {\n          type: 'LineString',\n          coordinates: geoJSON.coordinates[i]\n        };\n\n        if (within(ls, comparisonGeoJSON) === false) {\n          contains++;\n          return false;\n        }\n      }\n\n      return true; // multipolygon.within(polygon)\n    } else if (geoJSON.type === 'MultiPolygon') {\n      for (i = 0; i < geoJSON.coordinates.length; i++) {\n        var p1 = {\n          type: 'Polygon',\n          coordinates: geoJSON.coordinates[i]\n        };\n\n        if (within(p1, comparisonGeoJSON) === false) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }\n\n  if (comparisonGeoJSON.type === 'MultiPolygon') {\n    // point.within(multipolygon)\n    if (geoJSON.type === 'Point') {\n      if (comparisonGeoJSON.coordinates.length) {\n        for (i = 0; i < comparisonGeoJSON.coordinates.length; i++) {\n          coordinates = comparisonGeoJSON.coordinates[i];\n\n          if (polygonContainsPoint(coordinates, geoJSON.coordinates) && arraysIntersectArrays([geoJSON.coordinates], comparisonGeoJSON.coordinates) === false) {\n            return true;\n          }\n        }\n      }\n\n      return false; // polygon.within(multipolygon)\n    } else if (geoJSON.type === 'Polygon') {\n      for (i = 0; i < geoJSON.coordinates.length; i++) {\n        if (comparisonGeoJSON.coordinates[i].length === geoJSON.coordinates.length) {\n          for (var j = 0; j < geoJSON.coordinates.length; j++) {\n            if (coordinatesEqual(geoJSON.coordinates[j], comparisonGeoJSON.coordinates[i][j])) {\n              return true;\n            }\n          }\n        }\n      }\n\n      if (arraysIntersectArrays(geoJSON.coordinates, comparisonGeoJSON.coordinates) === false) {\n        if (comparisonGeoJSON.coordinates.length) {\n          for (i = 0; i < comparisonGeoJSON.coordinates.length; i++) {\n            coordinates = comparisonGeoJSON.coordinates[i];\n\n            if (polygonContainsPoint(coordinates, geoJSON.coordinates[0][0]) === false) {\n              contains = false;\n            } else {\n              contains = true;\n            }\n          }\n\n          return contains;\n        }\n      } // linestring.within(multipolygon), multipoint.within(multipolygon)\n\n    } else if (geoJSON.type === 'LineString' || geoJSON.type === 'MultiPoint') {\n      for (i = 0; i < comparisonGeoJSON.coordinates.length; i++) {\n        var poly = {\n          type: 'Polygon',\n          coordinates: comparisonGeoJSON.coordinates[i]\n        };\n\n        if (within(geoJSON, poly)) {\n          return true;\n        }\n\n        return false;\n      } // multilinestring.within(multipolygon)\n\n    } else if (geoJSON.type === 'MultiLineString') {\n      for (i = 0; i < geoJSON.coordinates.length; i++) {\n        var _ls = {\n          type: 'LineString',\n          coordinates: geoJSON.coordinates[i]\n        };\n\n        if (within(_ls, comparisonGeoJSON) === false) {\n          return false;\n        }\n      }\n\n      return true; // multipolygon.within(multipolygon)\n    } else if (geoJSON.type === 'MultiPolygon') {\n      for (i = 0; i < comparisonGeoJSON.coordinates.length; i++) {\n        var mpoly = {\n          type: 'Polygon',\n          coordinates: comparisonGeoJSON.coordinates[i]\n        };\n\n        if (within(geoJSON, mpoly) === false) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  } // default to false\n\n\n  return false;\n};\n\nvar contains = function contains(geoJSON, comparisonGeoJSON) {\n  return within(comparisonGeoJSON, geoJSON);\n};\n\nvar intersects = function intersects(geoJSON, comparisonGeoJSON) {\n  // if we are passed a feature, use the polygon inside instead\n  if (comparisonGeoJSON.type === 'Feature') {\n    comparisonGeoJSON = comparisonGeoJSON.geometry;\n  }\n\n  if (within(geoJSON, comparisonGeoJSON) || within(comparisonGeoJSON, geoJSON)) {\n    return true;\n  }\n\n  if (geoJSON.type !== 'Point' && geoJSON.type !== 'MultiPoint' && comparisonGeoJSON.type !== 'Point' && comparisonGeoJSON.type !== 'MultiPoint') {\n    return arraysIntersectArrays(geoJSON.coordinates, comparisonGeoJSON.coordinates);\n  } else if (geoJSON.type === 'Feature') {\n    // in the case of a Feature, use the internal geometry for intersection\n    var inner = geoJSON.geometry;\n    return intersects(inner, comparisonGeoJSON);\n  }\n\n  warn('Type ' + geoJSON.type + ' to ' + comparisonGeoJSON.type + ' intersection is not supported by intersects');\n  return false;\n};\n\nvar VINCENTY = {\n  a: 6378137,\n  b: 6356752.3142,\n  f: 1 / 298.257223563\n};\nvar toGeographic = function toGeographic(geojson) {\n  return applyConverter(geojson, positionToGeographic);\n};\nvar toCircle = function toCircle(center, radius, interpolate) {\n  var steps = interpolate || 64;\n  var rad = radius || 250;\n\n  if (!center || center.length < 2 || !rad || !steps) {\n    throw new Error('Terraformer: missing parameter for Terraformer.Circle');\n  }\n\n  return {\n    type: 'Feature',\n    geometry: createGeodesicCircle(center, rad, steps),\n    properties: {\n      radius: rad,\n      center: center,\n      steps: steps\n    }\n  };\n};\n/* cribbed from\n  http://stackoverflow.com/questions/24145205/writing-a-function-to-convert-a-circle-to-a-polygon-using-leaflet-js\n*/\n\nvar createGeodesicCircle = function createGeodesicCircle(center, radius, interpolate) {\n  var steps = interpolate || 64;\n  var polygon = {\n    type: 'Polygon',\n    coordinates: [[]]\n  };\n  var angle;\n\n  for (var i = 0; i < steps; i++) {\n    angle = i * 360 / steps;\n    polygon.coordinates[0].push(destinationVincenty(center, angle, radius));\n  }\n\n  polygon.coordinates = closedPolygon(polygon.coordinates);\n  return polygon;\n};\n\nvar destinationVincenty = function destinationVincenty(coords, brng, dist) {\n  var cos2SigmaM, sinSigma, cosSigma, deltaSigma;\n  var a = VINCENTY.a;\n  var b = VINCENTY.b;\n  var f = VINCENTY.f;\n  var lon1 = coords[0];\n  var lat1 = coords[1];\n  var s = dist;\n  var pi = Math.PI;\n  var alpha1 = brng * pi / 180; // converts brng degrees to radius\n\n  var sinAlpha1 = Math.sin(alpha1);\n  var cosAlpha1 = Math.cos(alpha1);\n  var tanU1 = (1 - f) * Math.tan(lat1 * pi / 180\n  /* converts lat1 degrees to radius */\n  );\n  var cosU1 = 1 / Math.sqrt(1 + tanU1 * tanU1);\n  var sinU1 = tanU1 * cosU1;\n  var sigma1 = Math.atan2(tanU1, cosAlpha1);\n  var sinAlpha = cosU1 * sinAlpha1;\n  var cosSqAlpha = 1 - sinAlpha * sinAlpha;\n  var uSq = cosSqAlpha * (a * a - b * b) / (b * b);\n  var A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));\n  var B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));\n  var sigma = s / (b * A);\n  var sigmaP = 2 * Math.PI;\n\n  while (Math.abs(sigma - sigmaP) > 1e-12) {\n    cos2SigmaM = Math.cos(2 * sigma1 + sigma);\n    sinSigma = Math.sin(sigma);\n    cosSigma = Math.cos(sigma);\n    deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));\n    sigmaP = sigma;\n    sigma = s / (b * A) + deltaSigma;\n  }\n\n  var tmp = sinU1 * sinSigma - cosU1 * cosSigma * cosAlpha1;\n  var lat2 = Math.atan2(sinU1 * cosSigma + cosU1 * sinSigma * cosAlpha1, (1 - f) * Math.sqrt(sinAlpha * sinAlpha + tmp * tmp));\n  var lambda = Math.atan2(sinSigma * sinAlpha1, cosU1 * cosSigma - sinU1 * sinSigma * cosAlpha1);\n  var C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));\n  var lam = lambda - (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));\n  var lamFunc = lon1 + lam * 180 / pi; // converts lam radius to degrees\n\n  var lat2a = lat2 * 180 / pi; // converts lat2a radius to degrees\n\n  return [lamFunc, lat2a];\n};\n\n/* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n/**\n * Calculate the envelope surrounding the input.\n * @function\n * @param {object} GeoJSON - The input [GeoJSON](https://tools.ietf.org/html/rfc7946) Geometry, Feature, GeometryCollection or FeatureCollection.\n * @return {Object} Object in the form { x, y, w, h }.\n * ```js\n * import { calculateEnvelope } from \"@terraformer/spatial\"\n *\n * calculateEnvelope({\n *   type: \"Point\",\n *   coordinates: [ 100, 100 ]\n * })\n *\n * >> { x: 100, y: 100, w: 0, h: 0, }\n * ```\n */\n\nvar calculateEnvelope = function calculateEnvelope(geojson) {\n  var bounds = calculateBounds(geojson);\n  return {\n    x: bounds[0],\n    y: bounds[1],\n    w: Math.abs(bounds[0] - bounds[2]),\n    h: Math.abs(bounds[1] - bounds[3])\n  };\n};\n/**\n * Reproject WGS84 (Lat/Lng) GeoJSON to Web Mercator.\n * @function\n * @param {object} GeoJSON - The input [GeoJSON](https://tools.ietf.org/html/rfc7946) Geometry, Feature, GeometryCollection or FeatureCollection.\n * @return {object} GeoJSON\n * ```js\n * import { toMercator } from \"@terraformer/spatial\"\n *\n * toMercator({\n *   type: \"Point\",\n *   coordinates: [ 45, 60 ]\n * })\n *\n * >> { type: \"Point\", coordinates: [ -13580978, 5621521 ], crs }\n * ```\n */\n\nvar toMercator = function toMercator(geojson) {\n  return applyConverter(geojson, positionToMercator);\n};\n\nexport { GeographicCRS, MercatorCRS, calculateBounds, calculateEnvelope, contains, convexHull, intersects, isConvex, polygonContainsPoint, positionToGeographic, positionToMercator, toCircle, toGeographic, toMercator, within };\n","import * as L from 'leaflet';\r\nimport * as GeoJSON from 'geojson';\r\nimport { calculateBounds, toCircle, contains, intersects } from '@terraformer/spatial';\r\n\r\nfunction geoJSONGeometryToBounds(geometry: GeoJSON.GeometryObject) {\r\n    const bounds = calculateBounds(geometry);\r\n    const leafletBounds = L.latLngBounds([bounds[1], bounds[0]], [bounds[3], bounds[2]]);\r\n    return leafletBounds;\r\n}\r\n\r\nfunction getCircleMarkerRadius(circleMarker: L.CircleMarker, crs: L.CRS, zoom: number) {\r\n    const latLng = circleMarker.getLatLng();\r\n    const point = crs.latLngToPoint(latLng, zoom);\r\n    const delta = circleMarker.getRadius() / Math.SQRT2;\r\n    const topLeftPoint = L.point([point.x - delta, point.y - delta]);\r\n    const topLeftLatLng = crs.pointToLatLng(topLeftPoint, zoom);\r\n    const radius = crs.distance(latLng, topLeftLatLng);\r\n    return radius;\r\n}\r\n\r\nfunction circleToGeoJSONGeometry(latLng: L.LatLng, radius: number) {\r\n    return toCircle(L.GeoJSON.latLngToCoords(latLng), radius).geometry;\r\n}\r\n\r\nfunction layerToGeoJSONGeometry(layer: L.Layer, options: { zoom?: number, crs?: L.CRS } = {}) {\r\n    if (layer instanceof L.Circle) {\r\n        const latLng = layer.getLatLng();\r\n        const radius = layer.getRadius();\r\n        return circleToGeoJSONGeometry(latLng, radius);\r\n    } else if (layer instanceof L.CircleMarker) {\r\n        if (options.zoom != undefined && options.crs != undefined) {\r\n            const latLng = layer.getLatLng();\r\n            const radius = getCircleMarkerRadius(layer, options.crs, options.zoom);\r\n            return circleToGeoJSONGeometry(latLng, radius);\r\n        } else {\r\n            console.warn(\"Zoom and CRS is required for calculating CircleMarker polygon, falling back to center point only\");\r\n            return layer.toGeoJSON().geometry;\r\n        }\r\n    } else if (layer instanceof L.Marker || layer instanceof L.Polyline) {\r\n        return layer.toGeoJSON().geometry;\r\n    }\r\n}\r\n\r\nfunction polygonContains(polygon: GeoJSON.Polygon, layerGeometry: GeoJSON.GeometryObject) {\r\n    return contains(polygon, layerGeometry);\r\n}\r\n\r\nfunction polygonIntersects(polygon: GeoJSON.Polygon, layerGeometry: GeoJSON.GeometryObject) {\r\n    if (layerGeometry.type === \"Point\") {\r\n        return contains(polygon, layerGeometry);\r\n    }\r\n\r\n    // try contains first (fast), then intersects (slower)\r\n    return contains(polygon, layerGeometry) || intersects(polygon, layerGeometry);\r\n}\r\n\r\nexport function getLayersInPolygon(polygon: L.Polygon, layers: L.Layer[], options: { zoom?: number, crs?: L.CRS, intersect?: boolean } = {}) {\r\n    const polygonGeometry = polygon.toGeoJSON().geometry as GeoJSON.Polygon;\r\n    const polygonBounds = polygon.getBounds();\r\n\r\n    const selectedLayers = layers.filter(layer => {\r\n        // check bounds first (fast)\r\n        let layerGeometry;\r\n        let layerBounds;\r\n        if (layer instanceof L.Polyline) {\r\n            layerBounds = layer.getBounds();\r\n        } else {\r\n            layerGeometry = layerToGeoJSONGeometry(layer, options);\r\n            layerBounds = geoJSONGeometryToBounds(layerGeometry);\r\n        }\r\n\r\n        if (!polygonBounds.intersects(layerBounds)) {\r\n            return false;\r\n        }\r\n\r\n        // check full geometry (slower)\r\n        if (!layerGeometry) {\r\n            layerGeometry = layerToGeoJSONGeometry(layer, options);\r\n        }\r\n\r\n        return options.intersect ?\r\n            polygonIntersects(polygonGeometry, layerGeometry) :\r\n            polygonContains(polygonGeometry, layerGeometry);\r\n    });\r\n    \r\n    return selectedLayers;\r\n}","function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","import * as L from 'leaflet';\r\nimport { LassoPolygon } from './lasso-polygon';\r\nimport { getLayersInPolygon } from './calc';\r\nimport './lasso-handler.css';\r\n\r\nexport interface LassoHandlerOptions {\r\n    polygon?: L.PolylineOptions,\r\n    intersect?: boolean;\r\n}\r\n\r\ninterface LassoHandlerFinishedEventData {\r\n    latLngs: L.LatLng[];\r\n    layers: L.Layer[];\r\n}\r\n\r\nexport type LassoHandlerFinishedEvent = L.LeafletEvent & LassoHandlerFinishedEventData;\r\n\r\nexport const ENABLED_EVENT = 'lasso.enabled';\r\nexport const DISABLED_EVENT = 'lasso.disabled';\r\nexport const FINISHED_EVENT = 'lasso.finished';\r\n\r\nexport const ACTIVE_CLASS = 'leaflet-lasso-active';\r\n\r\nexport class LassoHandler extends L.Handler {\r\n    options: LassoHandlerOptions = {\r\n        polygon: {\r\n            color: '#00C3FF',\r\n            weight: 2,\r\n        },\r\n        intersect: false,\r\n    };\r\n\r\n    private map: L.Map;\r\n\r\n    private polygon?: LassoPolygon;\r\n\r\n    private onDocumentMouseMoveBound = this.onDocumentMouseMove.bind(this);\r\n    private onDocumentMouseUpBound = this.onDocumentMouseUp.bind(this);\r\n    private onDocumentTouchStartBound = this.onDocumentTouchStart.bind(this);\r\n    private onDocumentTouchMoveBound = this.onDocumentTouchMove.bind(this);\r\n    private onDocumentTouchEndBound = this.onDocumentTouchEnd.bind(this);\r\n\r\n    constructor(map: L.Map, options: LassoHandlerOptions = {}) {\r\n        super(map);\r\n        \r\n        this.map = map;\r\n        L.Util.setOptions(this, options);\r\n    }\r\n\r\n    setOptions(options: LassoHandlerOptions) {\r\n        this.options = { ...this.options, ...options };\r\n    }\r\n\r\n    toggle() {\r\n        if (this.enabled()) {\r\n            this.disable();\r\n        } else {\r\n            this.enable();\r\n        }\r\n    }\r\n    \r\n    addHooks() {\r\n        this.map.getPane('mapPane');\r\n        this.map.on('mousedown', this.onMapMouseDown, this);\r\n        document.addEventListener('touchstart', this.onDocumentTouchStartBound);\r\n\r\n        const mapContainer = this.map.getContainer();\r\n        mapContainer.classList.add(ACTIVE_CLASS);\r\n\r\n        this.map.dragging.disable();\r\n        this.map.fire(ENABLED_EVENT);\r\n    }\r\n\r\n    removeHooks() {\r\n        if (this.polygon) {\r\n            this.map.removeLayer(this.polygon);\r\n            this.polygon = undefined;\r\n        }\r\n\r\n        this.map.off('mousedown', this.onMapMouseDown, this);\r\n        document.removeEventListener('mousemove', this.onDocumentMouseMoveBound);\r\n        document.removeEventListener('mouseup', this.onDocumentMouseUpBound);\r\n        document.removeEventListener('touchstart', this.onDocumentTouchStartBound);\r\n        document.removeEventListener('touchmove', this.onDocumentTouchMoveBound);\r\n        document.removeEventListener('touchend', this.onDocumentTouchEndBound);\r\n\r\n        this.map.getContainer().classList.remove(ACTIVE_CLASS);\r\n        document.body.classList.remove(ACTIVE_CLASS);\r\n\r\n        this.map.dragging.enable();\r\n        this.map.fire(DISABLED_EVENT);\r\n    }\r\n\r\n    private onMapMouseDown(event: L.LeafletEvent) {\r\n        const event2 = event as L.LeafletMouseEvent;\r\n\r\n        // ignore leaflet simulated event\r\n        if (event2.originalEvent.buttons === 0) {\r\n            return;\r\n        }\r\n\r\n        // activate lasso only for left mouse button click\r\n        if (event2.originalEvent.buttons !== 1) {\r\n            this.disable();\r\n            return;\r\n        }\r\n\r\n        // skip clicks on controls\r\n        if ((event2.originalEvent.target as HTMLElement).closest('.leaflet-control-container')) {\r\n            return;\r\n        }\r\n\r\n        this.polygon = new LassoPolygon([event2.latlng], this.options.polygon).addTo(this.map);\r\n\r\n        document.body.classList.add(ACTIVE_CLASS);\r\n\r\n        document.addEventListener('mousemove', this.onDocumentMouseMoveBound);\r\n        document.addEventListener('mouseup', this.onDocumentMouseUpBound);\r\n    }\r\n\r\n    private onDocumentMouseMove(event: Event) {\r\n        if (!this.polygon) {\r\n            return;\r\n        }\r\n\r\n        const event2 = event as MouseEvent;\r\n\r\n        // ignore leaflet simulated event\r\n        if (event2.buttons === 0) {\r\n            return;\r\n        }\r\n\r\n        // keep lasso active only if left mouse button is hold\r\n        if (event2.buttons !== 1) {\r\n            console.warn('mouseup event was missed');\r\n            this.finish();\r\n            return;\r\n        }\r\n\r\n        this.polygon.addLatLng(this.map.mouseEventToLatLng(event2));\r\n    }\r\n\r\n    private onDocumentMouseUp() {\r\n        this.finish();\r\n    }\r\n\r\n    private onDocumentTouchStart(event: TouchEvent) {\r\n        if (event.touches.length !== 1) {\r\n            this.disable();\r\n            return;\r\n        }\r\n        event.target?.dispatchEvent(this.convertTouchEventToMouseEvent(event, 'mousedown'));\r\n\r\n        document.addEventListener('touchmove', this.onDocumentTouchMoveBound);\r\n        document.addEventListener('touchend', this.onDocumentTouchEndBound);\r\n    }\r\n\r\n    private onDocumentTouchMove(event: TouchEvent) {\r\n        if (event.touches.length !== 1) {\r\n            this.finish();\r\n            return;\r\n        }\r\n        event.target?.dispatchEvent(this.convertTouchEventToMouseEvent(event, 'mousemove'));\r\n    }\r\n\r\n    private onDocumentTouchEnd() {\r\n        this.finish();\r\n    }\r\n    \r\n    private convertTouchEventToMouseEvent(event: TouchEvent, mouseEventType: string): MouseEvent {\r\n        const touches = event.changedTouches;\r\n        const touch = touches[0];\r\n        const mouseEvent = new MouseEvent(\r\n            mouseEventType,\r\n            {\r\n                bubbles: true,\r\n                cancelable: true,\r\n                view: window,\r\n                detail: 1,\r\n                screenX: touch.screenX,\r\n                screenY: touch.screenY,\r\n                clientX: touch.clientX,\r\n                clientY: touch.clientY,\r\n                ctrlKey: false,\r\n                altKey: false, \r\n                shiftKey: false,\r\n                metaKey: false,\r\n                button: 0,\r\n                relatedTarget: null,\r\n                buttons: 1,\r\n            }\r\n        );\r\n        return mouseEvent;\r\n    }\r\n\r\n    private finish() {\r\n        if (!this.polygon) {\r\n            return;\r\n        }\r\n\r\n        const layers: L.Layer[] = [];\r\n        this.map.eachLayer(layer => {\r\n            if (layer === this.polygon || layer === this.polygon!.polyline || layer === this.polygon!.polygon) {\r\n                return;\r\n            }\r\n\r\n            if (layer instanceof L.Marker || layer instanceof L.Path) {\r\n                layers.push(layer);\r\n            } else if (L.MarkerCluster && layer instanceof L.MarkerCluster) {\r\n                layers.push(...layer.getAllChildMarkers());\r\n            }\r\n        });\r\n\r\n        const selectedFeatures = getLayersInPolygon(this.polygon.polygon, layers, {\r\n            zoom: this.map.getZoom(),\r\n            crs: this.map.options.crs,\r\n            intersect: this.options.intersect,\r\n        });\r\n\r\n        this.map.fire(FINISHED_EVENT, {\r\n            latLngs: this.polygon.getLatLngs(),\r\n            layers: selectedFeatures,\r\n        } as LassoHandlerFinishedEventData);\r\n\r\n        this.disable();\r\n    }\r\n}\r\n","import * as L from 'leaflet';\r\nimport { LassoHandler, LassoHandlerOptions } from './lasso-handler';\r\nimport './lasso-control.css';\r\n\r\nexport type LassoControlOptions = LassoHandlerOptions & L.ControlOptions;\r\n\r\nexport class LassoControl extends L.Control {\r\n    options: LassoControlOptions = {\r\n        position: 'topright',\r\n    };\r\n\r\n    private lasso?: LassoHandler;\r\n\r\n    constructor(options: LassoControlOptions = {}) {\r\n        super();\r\n\r\n        L.Util.setOptions(this, options);\r\n    }\r\n\r\n    setOptions(options: LassoControlOptions) {\r\n        this.options = { ...this.options, ...options };\r\n        \r\n        if (this.lasso) {\r\n            this.lasso.setOptions(this.options);\r\n        }\r\n    }\r\n\r\n    onAdd(map: L.Map) {\r\n        this.lasso = new LassoHandler(map, this.options);\r\n\r\n        const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control') as HTMLDivElement;\r\n        const button = L.DomUtil.create('a', 'leaflet-control-lasso', container) as HTMLAnchorElement;\r\n        button.href = '#';\r\n        button.title = 'Toggle Lasso';\r\n        button.setAttribute('role', 'button');\r\n        button.setAttribute('aria-label', button.title);\r\n\r\n        L.DomEvent.addListener(button, 'click', this.toggle, this);\r\n        L.DomEvent.disableClickPropagation(button);\r\n\r\n        return container;\r\n    }\r\n\r\n    enabled() {\r\n        if (!this.lasso) {\r\n            return false;\r\n        }\r\n        return this.lasso.enabled();\r\n    }\r\n\r\n    enable() {\r\n        if (!this.lasso) {\r\n            return;\r\n        }\r\n        this.lasso.enable();\r\n    }\r\n\r\n    disable() {\r\n        if (!this.lasso) {\r\n            return;\r\n        }\r\n        this.lasso.disable();\r\n    }\r\n\r\n    toggle() {\r\n        if (!this.lasso) {\r\n            return;\r\n        }\r\n        this.lasso.toggle();\r\n    }\r\n}\r\n","import 'leaflet';\r\nimport { LassoHandler } from './lasso-handler';\r\nimport { LassoControl } from './lasso-control';\r\n\r\ndeclare module 'leaflet' {\r\n    type Lasso = LassoHandler;\r\n    let Lasso: typeof LassoHandler;\r\n\r\n    let lasso: (...args: ConstructorParameters<typeof LassoHandler>) => LassoHandler;\r\n    \r\n    namespace Control {\r\n        type Lasso = LassoControl;\r\n        let Lasso: typeof LassoControl;\r\n    }\r\n\r\n    namespace control {\r\n        let lasso: (...args: ConstructorParameters<typeof LassoControl>) => LassoControl;\r\n    }\r\n}\r\n\r\nif (typeof window.L !== 'undefined') {\r\n    window.L.Lasso = LassoHandler;\r\n    window.L.lasso = (...args: ConstructorParameters<typeof LassoHandler>) => new LassoHandler(...args);\r\n\r\n    window.L.Control.Lasso = LassoControl;\r\n    window.L.control.lasso = (...args: ConstructorParameters<typeof LassoControl>) => new LassoControl(...args);\r\n}\r\n\r\nexport * from './lasso-handler';\r\nexport * from './lasso-control';"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__assign","assign","t","s","i","n","arguments","length","call","apply","__spreadArrays","il","r","k","a","j","jl","latlngs","options","_super","_this","polyline","L.polyline","polygon","L.polygon","weight","LassoPolygon","map","addTo","remove","latlng","addLatLng","getLatLngs","toGeoJSON","L.Layer","isNumber","isNaN","parseFloat","isFinite","edgeIntersectsEdge","a1","a2","b1","b2","uaT","ubT","uB","ua","ub","arraysIntersectArrays","l","coordinatesContainPoint","coordinates","point","contains","pointsEqual","compSort","p1","p2","closedPolygon","outer","inner","slice","push","coordinatesEqual","na","sort","nb","calculateBoundsFromNestedArrays","array","x1","x2","y1","y2","lonlat","lon","lat","calculateBoundsFromArray","calculateBoundsForFeatureCollection","featureCollection","extents","features","extent","calculateBounds","geometry","calculateBoundsForGeometryCollection","geometryCollection","geometries","geojson","type","innerinner","calculateBoundsFromNestedArrayOfArrays","Error","polygonContainsPoint","within","geoJSON","comparisonGeoJSON","intersects","args","console","warn","VINCENTY","createGeodesicCircle","center","radius","interpolate","angle","steps","destinationVincenty","coords","brng","dist","cos2SigmaM","sinSigma","cosSigma","f","lon1","lat1","pi","Math","PI","alpha1","sinAlpha1","sin","cosAlpha1","cos","tanU1","tan","cosU1","sqrt","sinU1","sigma1","atan2","sinAlpha","cosSqAlpha","uSq","A","B","sigma","sigmaP","abs","tmp","lat2","C","circleToGeoJSONGeometry","latLng","rad","properties","toCircle","L.GeoJSON","latLngToCoords","layerToGeoJSONGeometry","layer","L.Circle","getLatLng","getRadius","L.CircleMarker","undefined","zoom","crs","circleMarker","latLngToPoint","delta","SQRT2","topLeftPoint","L.point","x","y","topLeftLatLng","pointToLatLng","distance","getCircleMarkerRadius","L.Marker","L.Polyline","getLayersInPolygon","layers","polygonGeometry","polygonBounds","getBounds","filter","layerGeometry","layerBounds","bounds","L.latLngBounds","intersect","polygonIntersects","polygonContains","styleInject","css","ref","insertAt","document","head","getElementsByTagName","style","createElement","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","ACTIVE_CLASS","color","onDocumentMouseMove","bind","onDocumentMouseUp","onDocumentTouchStart","onDocumentTouchMove","onDocumentTouchEnd","L.Util","setOptions","LassoHandler","enabled","disable","enable","getPane","on","onMapMouseDown","addEventListener","onDocumentTouchStartBound","getContainer","classList","add","dragging","fire","removeLayer","off","removeEventListener","onDocumentMouseMoveBound","onDocumentMouseUpBound","onDocumentTouchMoveBound","onDocumentTouchEndBound","body","event","event2","originalEvent","buttons","target","closest","finish","mouseEventToLatLng","touches","dispatchEvent","convertTouchEventToMouseEvent","mouseEventType","touch","changedTouches","MouseEvent","bubbles","cancelable","view","window","detail","screenX","screenY","clientX","clientY","ctrlKey","altKey","shiftKey","metaKey","button","relatedTarget","eachLayer","L.Path","L.MarkerCluster","getAllChildMarkers","selectedFeatures","getZoom","latLngs","L.Handler","position","LassoControl","lasso","container","L.DomUtil","href","title","setAttribute","L.DomEvent","addListener","toggle","disableClickPropagation","L.Control","L","Lasso","_i","Control","control"],"mappings":"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"}